# Generates NONTERMINAL_MAPPING.md by mechanically mapping nonterminals in elixir_parser.yrl
# to references found in this codebase.
#
# Usage:
#   mix run scripts/nonterminal_mapping.exs
#
# Output:
#   NONTERMINAL_MAPPING.md (workspace root)

root = File.cwd!()

yrl_path = Path.join(root, "elixir_parser.yrl")
nonterminals_md_path = Path.join(root, "NONTERMINALS_GPT.md")
out_path = Path.join(root, "NONTERMINAL_MAPPING.md")

unless File.exists?(yrl_path) do
  raise "Missing #{yrl_path}"
end

# --- 1) Extract nonterminals from yrl (LHS of productions) ---

yrl = File.read!(yrl_path)

nonterminals =
  Regex.scan(~r/^\s*([a-z][a-zA-Z0-9_]*)\s*->/m, yrl, capture: :all_but_first)
  |> List.flatten()
  |> Enum.uniq()
  |> Enum.sort()

# --- 2) Load intended strategy mapping (if present) ---

strategy_map =
  if File.exists?(nonterminals_md_path) do
    File.read!(nonterminals_md_path)
    |> String.split("\n")
    |> Enum.reduce(%{}, fn line, acc ->
      case String.split(line, ":", parts: 2) do
        [lhs, rhs] ->
          key = lhs |> String.trim()
          val = rhs |> String.trim()
          if key != "" and val != "" do
            Map.put(acc, key, val)
          else
            acc
          end

        _ ->
          acc
      end
    end)
  else
    %{}
  end

# --- 3) Scan lib/**/*.ex for grammar references ---
#
# We only treat a line as evidence if it contains a production-like marker
# (something matching "<nonterminal> ->") AND the extracted nonterminal is
# actually one we found in the yrl file. This keeps the mapping mechanical and
# avoids free-form guesses.

lib_files =
  Path.wildcard(Path.join(root, "lib/**/*.ex"))
  |> Enum.sort()

evidence_map =
  Enum.reduce(lib_files, %{}, fn file, acc ->
    rel = Path.relative_to(file, root)

    lines = File.read!(file) |> String.split("\n")

    {acc, _last_def} =
      Enum.with_index(lines, 1)
      |> Enum.reduce({acc, nil}, fn {line, line_no}, {acc2, last_def} ->
        last_def2 =
          case Regex.run(~r/^\s*defp?\s+([a-zA-Z0-9_?!]+)\b/, line, capture: :all_but_first) do
            [name] -> name
            _ -> last_def
          end

        # Find all occurrences of "<word> ->" in the line.
        # We then keep only those where <word> is a known yrl nonterminal.
        found =
          Regex.scan(~r/\b([a-z][a-zA-Z0-9_]*)\s*->/, line, capture: :all_but_first)
          |> List.flatten()
          |> Enum.filter(&(&1 in nonterminals))

        acc3 =
          Enum.reduce(found, acc2, fn nt, a ->
            entry = %{file: rel, line: line_no, function: last_def2, snippet: String.trim(line)}
            Map.update(a, nt, [entry], fn existing -> [entry | existing] end)
          end)

        {acc3, last_def2}
      end)

    acc
  end)

# Normalize evidence lists: stable order, de-dup identical entries.

evidence_map =
  Map.new(evidence_map, fn {nt, entries} ->
    uniq =
      entries
      |> Enum.uniq_by(fn e -> {e.file, e.line, e.function, e.snippet} end)
      |> Enum.sort_by(fn e -> {e.file, e.line} end)

    {nt, uniq}
  end)

# --- 4) Render markdown ---

defmodule Render do
  def md_escape(text) when is_binary(text) do
    text
    |> String.replace("|", "\\|")
    |> String.replace("\n", " ")
  end

  def link(file, line) do
    # workspace-relative path + 1-based line anchor
    "[#{file}](#{URI.encode(file)}#L#{line})"
  end

  def compact_loc(%{file: file, line: line, function: fun}) do
    fun_part = if is_binary(fun), do: "##{fun}", else: ""
    "#{link(file, line)}#{fun_part}"
  end

  def status(strategy, evidence) do
    has_strategy = is_binary(strategy)
    has_evidence = evidence != []

    cond do
      has_evidence -> "referenced"
      has_strategy -> "planned"
      true -> "unmapped"
    end
  end
end

header = """
# Nonterminal â†’ Implementation Mapping (Mechanical)

Generated by `scripts/nonterminal_mapping.exs`.

Legend:
- **status**:
  - `referenced`: the nonterminal appears in at least one in-repo grammar reference of the form `nonterminal -> ...` (usually in comments/docs).
  - `planned`: present in `NONTERMINALS_GPT.md` but no in-repo `nonterminal ->` reference was found.
  - `unmapped`: neither referenced nor planned.

Notes:
- This is intentionally conservative: it does **not** guess mappings based on function names.
- For conformance work, `referenced` is the best starting point because it points to concrete code locations.

"""

rows =
  Enum.map(nonterminals, fn nt ->
    strategy = Map.get(strategy_map, nt)
    evidence = Map.get(evidence_map, nt, [])

    status = Render.status(strategy, evidence)

    evidence_str =
      case evidence do
        [] -> ""
        entries ->
          entries
          |> Enum.take(4)
          |> Enum.map(&Render.compact_loc/1)
          |> Enum.join(" ")
      end

    count = length(evidence)

    "| #{nt} | #{status} | #{strategy || ""} | #{count} | #{evidence_str} |"
  end)

md =
  [
    header,
    "| nonterminal | status | strategy (NONTERMINALS_GPT.md) | refs | evidence (first 4) |",
    "|---|---|---|---:|---|"
    | rows
  ]
  |> Enum.join("\n")
  |> Kernel.<>("\n")

File.write!(out_path, md)

IO.puts("Wrote #{Path.relative_to(out_path, root)} (#{length(nonterminals)} nonterminals)")
