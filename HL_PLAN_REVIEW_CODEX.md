# HL_PLAN Review (Codex)

Findings (highest severity first):
- Token adapter (Phase 1) omits tolerant-mode specifics from Toxic: no plan to surface `error_token` nodes, synthesized closers, or the terminator stack/current terminators coming from the stream; checkpoint/rewind and `peek_n` scopes are not bounded per HLD, and EOE handling ignores `*_op_eol` newline metadata. Clarify how `eol`/`;` are normalized, how newline counts are preserved, and how lexer diagnostics flow into parser errors.
- Pratt core (Phase 2) treats `do` like a normal operator but does not describe the intended grammar-layer-only suffix handling; also missing dot vs dot-call differentiation, access adornment (`[]`) binding, and the restriction that `do` blocks attach only via grammar (`block_expr`) not raw Pratt. Spell out how `dual_op` spacing and `not in` combined operator are recognized (from token shapes).
- Expression families (Phase 3) lack the no-parens nesting/arity restrictions, `matched` vs `unmatched` threading, and the `block_expr` cases (`dot_do_identifier`, nested paren calls + do, do-block bans inside no-parens many). Add explicit rules for `no_parens_one/many/ambig`, how ambiguity is resolved (outer arity 1), and where `warn_pipe`/`warn_no_parens_after_do_op` equivalents fire.
- Calls & identifiers (Phase 4) miss keyword/do disambiguation rules (`maybe_bad_keyword_*`, keyword-last enforcement), quoted identifier rewrites (`quoted_paren/bracket/do/op_identifier_end`), and do-block attachment precedence (no-parens vs parens vs nested parens). Clarify how bracket identifiers decide between access vs list start (limited `peek_n`).
- Containers (Phase 5) skip important details: bitstring segment/modifier parsing and trailing-comma rules, map update vs assoc vs kw-only maps, and how kw tails are handled inside containers with EOE normalization. Add sync/terminator usage for `]`, `}`, `>>`.
- Strings/sigils/heredocs (Phase 7) are under-specified: need to consume linear Toxic tokens (`*_start`/`string_fragment`/`*_end`) with indentation stripping, interpolation recovery (`begin/end_interpolation`), heredoc/sigil indentation metadata, and synthesis of missing end tokens. Quoted atoms/keywords identifiers and `capture_int` spacing need coverage.
- Event log + builders (Phases 8 & 11) list event types but do not define ordering guarantees, node kinds, or how builders subscribe to events to produce AST/CST/outline/environment. HLD calls event log the primary output; lock schema and metadata (ranges, delimiters, synthesized flags) before wiring parse code to avoid rework.
- Recovery (Phase 10) lacks per-nonterminal sync sets using the terminator stack, rules for when to synthesize missing tokens vs skip, and a fuel/progress guard. Include how lexer errors become error nodes without double-reporting, and how `missing` vs `synthetic` events are emitted.
- Environment stream (Phase 9) is not integrated with parsing actions: specify when to emit `enter/exit_scope`, bindings in patterns (match lhs, fn/case/with/for generators), aliases/imports/uses, and how tolerant-mode synthetic pieces affect env events.
- Testing (Phase 12) is too light relative to HLD: add strict vs tolerant conformance against `Code.string_to_quoted`, targeted fixtures (no-parens nesting bans, pipe into call ambiguity, keyword-last, missing end/closers, open heredocs/sigils, `not in` rewrite, `..//` misuse, `capture_int` spacing), lexer-error passthrough, and large corpus/perf checks. Property/fuzz tests should include Toxic error-mode streams.
- Public API/opts (Phase 12) need strict vs tolerant behavior definition, diagnostic aggregation policy, event/env/comment output combinations, and how metadata options affect builders. Clarify default options and backward compatibility with `Code.string_to_quoted_with_comments`.

Ordering/clarity suggestions:
- Define the event log schema, AST builder contract, and metadata policy before implementing Pratt/grammar so emission points are clear.
- Pull recovery sync-set definitions earlier (with token adapter/grammar) to avoid bolting on error handling later.
- Thread environment emission design alongside grammar (not after) so clauses/blocks emit scope events as they’re implemented.
- Add a short “tolerant vs strict” behavior spec after Phase 1 to guide later phases (lexer errors, synthesized closers, diagnostics).
